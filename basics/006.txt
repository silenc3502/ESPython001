1. 클래스란 무엇인가 ?
   - C로 생각하면 구조체
   ---> 구조체는 왜 사용하는가 ?
   ----- 변수 관리의 용이성
   ----> 변수 관리의 용이성이 왜 필요한가 ?
   ------- 특정한 정보에 대한 집합체가 필요해서 사용한다.
   ex) 사람: 눈, 뇌, 코, 입 등등
       그리고 각각은 기능들을 가지고 있다.
       눈: 보는 것(Vision)
       코: 향을 맡는것(Air Sensor)
       뇌: 지능(생각) - [ 인공 신경망(ANN) ]
       입: 음성(신호 처리 - 마이크, 스피커) 및
           식사(무선 전력 전송, 레이저 충전)

정보의 집합체들이 있고 이 집합체들을
잘 다루기 위한 기능들이 구성되면
이를 잘 만들어진 클래스라고 한다.
(Good Abstraction) - Class를 잘 만들려면 이 규칙을 따라줘야함

정보를 이루는 요소를 제어하는 기능이 알맞게 들어있어야 한다.

class def에 보면 항상 인자로 self가 따라오게 된다.
자기(메모리에 생성된 객체) 자신을
나타내는 일종의 포인터라고 볼 수 있다.
(C++이나 Java에서는 this로 표현하는 녀석과 동의어)

C++이나 Java에서는 Person p = new Person()
Python의 경우엔 데이터타입을 자동으로 맞추기 때문에
p = Person()이 된 것을 확인할 수 있을 것이다.
malloc()과 동일한 것이 new 이며
python의 경우엔 이것조차 생략한다.

구조체: 변수 + 함수 포인터 -> 클래스(다형성이 적용됨)

lxr linux task_struct

Elixir Bootlin으로 접속
task_struct를 검색해본다. 대략 600라인쯤에 있음
files_struct를 검색해본다.
task_struct 구조체 내부에 포인터 변수로 존재함
include/linux/fdtable.h를 누른다.
여기서 file 구조체를 찾을 수 있다.
include/linux/fs.h에서 정보를 확인할 수 있다.
그러면 해당 구조체에 있는 file_operations를 볼 수 있다.
내부에서 함수 포인터의 집합을 확인할 수 있다.

open, read, write
open을 통해서 fd를 얻어온다.
첫번째 초점 - fd값이 뭐지 ????????

두번째 초점 - 유닉스/리눅스에서 왜 모든것은 파일인가 ?

세번째 초점 - open, read, write는 무엇을 제어하는것인가 ?

클래스이름.클래스내부함수(클래스 이름으로 만들어진 객체)
== p1.Print()
이 방식은 Java나 C++에서는 지원되지 않는 방식임

클래스 작성법

1. class를 적는다.
2. class 이름을 적는다.
3. 해당 class에서 다룰려고하는 정보들을 작성한다(변수)
4. 변수를 제어할 수 있는 기능들을 작성한다.
   (주의점: 반드시 self를 인자로 받아야한다)
5. 향후 배울 Access Control 기능을 추가해서 다룬다.



생성자란 ?
자동으로 new 혹은 malloc을 해주는 녀석이라고 보면 된다.
결론적으로 메모리 할당자라 보면 된다.
주의점은 클래스 이름과 동일한 함수가 생성자다.
(생성자를 호출하면 Heap 공간에 객체가 만들어진다)


예외

1. Python 언어는 반드시 class 내부에서 변수를 다룰 필요 없다.
   (필요하다면 외부에서 주입할 수 있다)
2. 외부에서 처음 만드는 정보는 무조건 전역적으로 초기화 된다.
3. 전체 클래스를 관장하는 정보는 __class__에 설정된다.
4. 기본적으로 __class__의 설정을 따르지만
   직접적으로 데이터를 전달하면
   __class__인 경우와는 별도의 정보를 가지게 될 수도 있다.



상속이란 ?
우리가 작성하는 프로그램중에 내부 변수와 기능이
같은 것들을 사용하는 경우가 굉장히 많다.
여기에 추가 기능을 구현하려고 하는 경우에 어떻게 해야할까 ?
그리고 이것을 재활용하고 싶다면 어떻게 해야할까 ?

1. 새로운 함수를 또 만들고 그 함수를 재활용한다.
   (기존에 이미 있는 함수의 코드가 반복된다)
2. 기존 기능에 새로운 기능을 아예 추가해버린다.
   (추가 기능이 필요 없는 경우 성능 오버헤드가 발생한다)
3. 상속을 활용한다.
   (기존 기능을 그대로 활용할 수도 있고
    추가 기능이 부착된 녀석들을 추가로 활용할 수도 있다)



상속을 수행하는 방법

1. class A(B): 형식으로 상속을 할 수 있다.
2. 위 케이스에서 A는 자식
3. 위 케이스에서 B는 부모
4. B의 정보를 A에게 상속한다라는 뜻

예외 케이스

1. object는 파이썬 전체를 관장하는 객체다.
   즉, 모든 정보에 대한 열람 권한을 가지고 있다 봐도 무방
2. object는 최상위로 조상 클래스라고 보면 되겠다.
3. object는 집합 개념으로 생각했을때 전체 집합
4. 다른 클래스들은 전체 집합내에 있는
   소중대규모 집합들이라고 생각하면 되겠다.



* 구조체는 ??????? 뭐지 ?

커스텀 데이터 타입(사용자 정의형 데이터 타입)
가만 보니까 클래스는 ????? 구조체
그렇다면 클래스도 커스텀 데이터 타입

C의 경우 어떤 데이터 타입이든 가리지 않고 다 받겠다
라는 경우 활용하는 것이 void * 이다.
반면 Java나 Python은 Object, object로 위 기법을 사용한다.



파이썬에서 생성자가 있다고 했었는데
생성자를 직접 구현해주는 작업이 바로 __init__ 에 해당한다.
C++이나 Java로 치면 인자가 1개인 생성자에 해당한다.
필요하다면 인자를 더 추가해도 무방하다.

__del__은 생성자와 반대로 객체를 소멸시키는 소멸자에 해당한다.
그래서 객체 변수의 스코프가 끝나는 지점에서 소멸한다.

생성자, 소멸자를 직접 제어하면 좋은점이 무엇일까 ?
클래스 내부 멤버 변수들을
직접 생성하는 시점에 초기화할 수 있다.



숙제

1. Raspberry Pi 4 Environment Settings 진행 완료!
2. 밀린 숙제들 진행하기!
3. Python Class 8p 예습!
4. 기존 숙제들중 잘 모르겠는 것들 카페에 1회 이상 질문하기!
5. 다음주 여름 휴가
