Q&A 1. 푸아송 분포의 사용 목적은 무엇인가 ?

Ans: 특정한 주기를 가지고 어떤 사건이 발생할 수 있는 정보에 적용할 수 있다.
     팝콘 기계가 주기를 가지고 고장나는 케이스, 범죄, 반도체 IC 소자 고장 등등

Q&A 2. 푸아송 분포의 경찰 문제에서의 마지막 대안은 ?

Ans: 43% 정도가 문제가 없을 확률이므로 절반도 안된다.
     그러므로 직원 관리를 평소보다 더 빡세게 진행한다.

Q&A 3. raise의 용도는 무엇인가 ?

Ans: Exception을 발생시킨다.
     원한다면 특정 Exception을 발생시킬 수 있다.

Q&A 4. python for문 안에서 변수를 꺼내 사용할 때 정의되지 않았다고 나오는데 이유가 무엇인가 ?

Ans: 파이썬은 인터프리팅 언어이다 보니 스코핑마다 자기 자신의 영역을 가지게 된다.
     그러므로 외부의 데이터를 참조하려면 global 키워드가 필요해진다.

Q&A 5. C언어 20 고개 문제를 어떻게 기능별로 분할해야할까 ?

Ans: 5번 문제 정답 참고!

Q&A 6. 5번 질문의 숨겨진 이유(이정도로 심하게 쪼갤 필요가 있는가 ?)

Ans: 동일 코드 작성시 재활용성의 향상
     스레드 프로그래밍 시에 작업이 분할되어 있을수록 TLP(Thread Level Parallelization)이 상승한다.
     즉, 멀티 코어 프로그래밍 환경에서는 기능들을 쪼갤 수록 효과적으로 스레드를 사용할 수 있다.

Q&A 7. 기계어 분석을 해보니 함수를 호출할 때마다
       Stack Frame 생성과 Stack Frame 해제 작업이 일어남을 확인할 수 있었다.
       그렇다면 함수를 여러개 만들어서 여러개 호출하는 것 자체가 비용 낭비가 될 수 있지 않을까 ?

Ans: 그래서 존재하는 keyword가 있으니 inline이다.
     inline이 붙으면 함수로 분리되어 있어도 컴파일시에 함수 호출 없이 기계어가 생성된다.
     이렇게 되면 재활용성 향상과 성능 향상을 함께 도모할 수 있다.

Q&A 8. 함수에서 함수를 호출할 때 무조건 inline이면 좋을까 ?

Ans: 운영체제가 Paging이란 것을 통해서 가상 메모리를 물리 메모리에 맵핑한다.
     이 경우 통채로 맵핑하게 되면 분량이 너무 많기 때문에 짧은 시간내에 모두 맵핑이 불가능하다.
     Memory Hierarchy 관점에서 봤을때 우선 디스크에서 내용을 읽고 메모리에 로드해야 한다.
     안그래도 느린데 내용도 많은 녀석을 한 번에 올린다면 굉장한 성능 저하가 발생할 것이다.
     (우리가 느낄때는 렉이 걸렸다고 느낄 것이다 - 혹은 로딩이 길다고 느낄 것이다)
     이 문제를 해결하기 위해 나온것이 Demand On Paging이라는 기법이다.
     필요하면 페이징을 수행해서 메모리에 로드하라는 의미로
     한 번에 통채로 페이징을 하는 것이 아니라 필요할때 필요한만큼만 페이징을 수행한다.
     프로그램의 text 코드도 메모리에 올라가야 하는 것이고
     물리 메모리의 최소 크기인 페이지라는 것은 4K에 해당한다.
     그러므로 모든 것을 inline 시킨다면 오히려 페이징 크기를 초과하게 되고
     추가적인 페이징을 유발하므로 속도는 반대로 떨어지게 된다.
     (여기에 페이지 자체를 캐쉬 해놓을 수도 있는데 이 페이지 캐쉬도 활용하지 못하는 사태가 발생한다)
     결론적으로 성능 측면에서 모든것을 inline으로 처리하는 것이 좋다고 할 수 없다.
     반대로 inline을 안쓰는게 또 좋다고 할 수도 없다.

Q&A 9. C에서 최대의 성능을 위해 함수 사용을 자제하는게 좋지 않을까 ?

Ans: 펌웨어와 범용 OS에서의 프로그래밍에 따라 달라질 수 있다.
     펌웨어 프로그래밍의 경우 클록 하나가 매우 소중할 수 있기 때문에 함수 호출을 최소화하는 것이 좋다.
     반면 범용 OS에서의 구동은 기본적으로 클록 스피드가 3G ~ 5GHz에 달하므로
     몇 클록정도 낭비하는 것에 민감하지 않으며
     오히려 프로그램 규모가 펌웨어에 비해 굉장히 크기 때문에
     재활용성이 결국 생산성으로 연결되므로 함수를 기능별로 분리하는 것이 더 중요하게 작용한다.

Q&A 10. 함수 호출도 branch 명령어인가요 ?

Ans: 맞습니다 - 파이프라인이 깨집니다.
     웨이퍼 크기가 커지면 CPU 스펙이 좋다진다는 의미 - 결국 가격이 올라간다.
     반면 웨이퍼가 작아지면 CPU 스펙이 떨어지고 가격은 싸진다.
     이때 파이프라인 단계 많다면 그만큼 웨이퍼 공간을
     파이프라인 구조가 많이 차지하게 되고 상대적으로 다른 기능 유닛들을 넣지 못하게 된다.
     또 branch가 발생했을 때 파이프라인이 길면 작업이 중단되는 시간도 길어지므로
     여러모로 단가도 낮추고 branch에 의한 타격도 완화할 수 있는 5단계 파이프라인이 일반적이다.

Q&A 11. 어셈블리어를 실제 기계어로 보는 방법은 무엇인가요 ?

Ans: gcc -g *.c를 하고 objdump -d a.out

Q&A 12. 전역 변수를 확인할 수 있는 방법은 무엇인가요 ?

Ans: 위와 같이 컴파일 하고 objdump -x a.out
     만약 변수 이름을 알고 있다면 objdump -x a.out | grep 변수명

Q&A 13. objdump 떳을때 가장 왼쪽에 있는 정보는 무엇인가 ?

Ans: 컴파일러가 관리하는 섹션 오프셋

Q&A 14. Load & Store Architecture

Ans: 일단 기본적인 RISC 아키텍처는 메모리 2 메모리 연산이 불가능하다.
     그렇기 때문에 Load 이후에 Store를 통해서 메모리를 제어한다.
     반면 CISC 아키텍처는 메모리 2 메모리 연산이 가능하다.
     그렇기 때문에 mov가 처리할 수 있는 케이스가 여러가지가 된다.
     레지스터 2 메모리, 메모리 2 레지스터, 레지스터 2 레지스터, 메모리 2 메모리
     메모리 표현한다는것이 최소 4바이트가 필요하지만
     레지스터를 표현하는 것은 구지 4바이트가 필요하지 않다.
     eax, ebx --> 57    eax, ecx --> 58



H.W

1. 복습(inline, Demand on Paging, objdump 활용법, 컴파일러 & 운영체제가 바라보는 메모리의 관점[Dynamic Linking], 14번 내용)
2. TLP(Thread Level Parallelization) 조사
3. DLP(Data Level Parallelization) 조사
4. ILP(Instruction Level Parallelization) 조사
5. 문제 은행[2]에서 풀었던 문제들을 좀 더 범용성 있게 리팩토링 해보자!
   (데이터가 정수, 소수, 문자열 등등 다양하게 들어오는 상황에서도 처리가 가능하게 변형!)
   특정 한 문제를 잡고 어떻게 하면 가장 범용적으로 처리할 수 있을지 고민해보자!
