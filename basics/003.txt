# 질문 사항들

1. 작업 저장소가 어딘가요 ?
   카페입니다.

2. const는 왜 사용하나요 ?
   여러 사람들이 협업할 때 문제가 생길 수 있습니다.
   문제가 발생할 여지를 원천 봉쇄하는 차원에서 사용합니다.

3. gdb 사용 방법을 알려주세요.
   먼저 아래와 같이 디버깅 옵션을 줘서 컴파일을 합니다.
   gcc -g c코드

   a.out 파일이 생성되면
   gdb a.out

   b main    # main에 브레이크 포인트를 건다.
   r         # run: 프로그램 동작
   disas     # disassembly로 어셈블리어를 확인한다.
   l         # C언어 레벨에서 현재 코드 리스팅을 함
   p         # 데이터를 보는데 활용하는 명령어
   ex) p 변수이름
   ex) p/x 변수이름    # 16진수 데이터로 보기
   info reg  # 현재 CPU의 레지스터 정보를 확인할 수 있다.
   x 메모리주소 # 메모리주소에 어떤 값이 들어있는지 확인할 수 있다.
   b 라인수  # 원하는 라인에 브레이크 포인트를 걸 수 있다.
   c         # 이미 한 번 run을 시킨 상태에서 다음 브레이크 포인트까지 직행

   0x7fffffffdca8 - rsp
   0x0            - rbp
   0x7fffffffdca0 - rsp

   컴퓨터에서 스택은 거꾸로 자란다.
   엄밀히 말해 Little Endian 구조를 가진 컴퓨터들은 스택이 거꾸로 자란다.

   32 bit - 2^32 = 42억 9천만
   가상메모리가 4GB라는 얘기를 많이 들어봤을 것이다.
   2^10byte = 1KB
   2^20byte = 1MB
   2^30byte = 1GB
   2^32byte = 4GB

   레지스터 하나를 통해 모든 가상메모리 공간을 제어할 수 있다!!!

4. 왜 goto가 함수 사용보다 좋은가요 ?
   위의 어셈블리어가 증명해줬음

5. data rate 문제가 발생한다면 아래 명령으로 jupyter를 다시 실행해주세요.
   third.ipynb 요건 앞서서 만들었던 파일 이름(즉 오늘자 파일명)
   jupyter notebook third.ipynb --NotebookApp.iopub_data_rate_limit=2147483647

6. 혹시 위에 케이스도 데이터량이나 I/O량이 너무 많아서 돌지 않을 수 있다.
   그렇다면 test.py 파일을 별도로 만들고
   python3 test.py 라고 입력하여 실행한다.

7. join()은 메모리 차원에서 데이터를 쌓아놓고 있는다.
   I/O가 많이 발생하다보니 한 번에 모아서 블록 단위로 처리를 한다.
   블록 디바이스 드라이버는 특정한 블록 단위로 데이터를 처리한다.
   I/O를 자주 발생시키는 것은 굉장히 비효율적이므로
   메모리에 I/O로 출력할 정보를 쌓아놓고 있다가
   일정량이 모이면 한 번에 출력하는 방식
   여기서는 결국 성능을 향상시키는 것이 목적이므로
   DMA(Direct Memory Access)를 사용하게 된다.

8. import는 외부 라이브러를 사용할 수 있게 해주는 명령어
   C언어로 치면 #include와 동일하다.

숙제:

Python Module 전까지 예습을 진행해주세요.
파이썬 및 C언어 문제가 목요일 저녁에 업로드 될 것입니다.
이 문제들을 풀어서 제출하도록 합니다.
예습을 진행하면서 이해가 되지 않는 부분들을 정리해서 질문을 작성합니다.
